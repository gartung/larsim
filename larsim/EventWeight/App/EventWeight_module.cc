////////////////////////////////////////////////////////////////////////
// Class:       EventWeight
// Module Type: producer
// File:        EventWeight_module.cc
//
// Generated at Fri Mar 20 09:36:11 2015 by Zarko Pavlovic using artmod
// from cetpkgsupport v1_08_04.
//
// Ported from uboonecode to larsim on Feb 14 2018 by Marco Del Tutto
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "nutools/RandomUtils/NuRandomService.h"
#include "lardataobj/Simulation/sim.h"
#include "art/Framework/Services/Optional/RandomNumberGenerator.h"
#include "canvas/Persistency/Common/Assns.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>
#include <iostream>
#include <iomanip>

#include "larsim/EventWeight/Base/Weight_t.h"
#include "larsim/EventWeight/Base/MCEventWeight.h"
#include "larsim/EventWeight/Base/WeightCalc.h"
#include "larsim/EventWeight/Base/WeightCalcFactory.h"
#include "larsim/EventWeight/Base/WeightManager.h"

#include "nusimdata/SimulationBase/MCTruth.h"

// GENIE includes here are needed only for v3+
#ifndef GENIE_PRE_R3
  #include "Framework/Utils/RunOpt.h"
  #include "Framework/Utils/XSecSplineList.h"
#endif

namespace evwgh {

  class EventWeight : public art::EDProducer {
  public:
    explicit EventWeight(fhicl::ParameterSet const & p);
    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    EventWeight(EventWeight const &) = delete;
    EventWeight(EventWeight &&) = delete;
    EventWeight & operator = (EventWeight const &) = delete;
    EventWeight & operator = (EventWeight &&) = delete;

  private:
    // Required functions.
    void produce(art::Event & e) override;

    //Optional functions.
    void endJob() override;

    // Ensures that, when running with GENIE v3+, the tune configuration
    // is loaded even when the EventWeight module is run independently
    // from the GENIEGen module.
    void CheckTune(const std::string& tune_name);

    WeightManager _wgt_manager;
    std::string fGenieModuleLabel;
  };

  EventWeight::EventWeight(fhicl::ParameterSet const & p)
    : EDProducer{p}
    , fGenieModuleLabel{p.get<std::string>("genie_module_label", "generator")}
  {
    // Check that the GENIE tune is configured (v3+ only)
    this->CheckTune( p.get<std::string>("TuneName", "${GENIE_XSEC_TUNE}") );
    auto const n_func = _wgt_manager.Configure(p, *this);
    if ( n_func > 0 )
      produces<std::vector<MCEventWeight> >();
  }

  void EventWeight::produce(art::Event & e)
  {
    // Implementation of required member function here.
    auto mcwghvec = std::make_unique<std::vector<MCEventWeight>>();

    // Get the MC generator information out of the event
    // these are all handles to mc information.
    std::vector<art::Ptr<simb::MCTruth> > mclist;

      // Actually go and get the stuff
    auto const mcTruthHandle = e.getValidHandle<std::vector<simb::MCTruth>>(fGenieModuleLabel);
      art::fill_ptr_vector(mclist, mcTruthHandle);

    // Loop over all neutrinos in this event
    for (unsigned int inu = 0; inu < mclist.size(); ++inu) {
      auto const mcwgh = _wgt_manager.Run(e, inu);
      mcwghvec->push_back(mcwgh);
    }

    e.put(std::move(mcwghvec));
  }

  void EventWeight::endJob()
  {
    // Get the map from sting to Weight_t from the manager
    std::map<std::string, Weight_t*> weightCalcMap = _wgt_manager.GetWeightCalcMap();

    std::stringstream job_summary;
    job_summary  <<  std::setprecision(2);
    for (int i=1; i <= 110 ;i++) job_summary << "=";
    job_summary << std::endl;
    job_summary << std::setw(20) << "WeightCalc"
                << std::setw(15) << "Type"
                << std::setw(15) << "#RW neutrinos"
                << std::setw(15) << "#Multisims"
                << std::setw(15) << "Min"
                << std::setw(15) << "Max"
                << std::setw(15) << "Avg"
                << std::endl;
    for (int i=1; i <= 110; i++) job_summary << "=";
    job_summary << std::endl;
    for (auto it = weightCalcMap.begin(); it!=weightCalcMap.end(); it++) {
      job_summary << std::setw(20) << it->first
                  << std::setw(15) << (it->second->fWeightCalcType)
                  << std::setw(15) << (it->second->fNcalls)
                  << std::setw(15) << (it->second->fNmultisims)
                  << std::setw(15) << (it->second->fMinWeight)
                  << std::setw(15) << (it->second->fMaxWeight)
                  << std::setw(15) << (it->second->fAvgWeight)
                  << std::endl;
    }
    for (int i=1; i<=110; i++) job_summary << "=";
    job_summary << std::endl;
    mf::LogInfo("") << job_summary.str();
  }

  // Based on GENIEHelper::FindTune()
  // TODO: reduce code duplication here
  // -- S. Gardiner, 20 December 2018
  void EventWeight::CheckTune(const std::string& tune_name) {
// The tune configuration only needs to be checked for GENIE v3+
#ifndef GENIE_PRE_R3

    std::string fhicl_tune_name = tune_name;

    // The default tune name is ${GENIE_XSEC_TUNE}, which
    // should be converted into the value of the corresponding
    // enviornment variable, as is done below.
    if ( fhicl_tune_name.front() == '$' ) {
      // need to remove ${}'s
      std::string tuneEnvVar = fhicl_tune_name;
      std::string rmchars("$(){} ");
      // std::remove_if removes characters in [first,last) that are found
      //   within the rmchars string. It returns returns a past-the-end
      //   iterator for the new end of the range [funky!]
      // std::string::erase actually trims the string
      tuneEnvVar.erase( std::remove_if(tuneEnvVar.begin(), tuneEnvVar.end(),
        [&rmchars](const char& c) -> bool { return rmchars.find(c) != std::string::npos; }),
        tuneEnvVar.end() );

      const char* tune = std::getenv( tuneEnvVar.c_str() );
      if ( tune ) {
        mf::LogInfo("EventWeight") << "fhicl_tune_name started as '"
          << fhicl_tune_name << "' " << " (env: " << tuneEnvVar << "), "
          << " converted to " << tune;
        fhicl_tune_name = std::string(tune);
      } else {
        mf::LogError("EventWeight") << "fhicl_tune_name started as '"
          << fhicl_tune_name << "', " << " (env: " << tuneEnvVar << "), "
          << " but resolved to a empty string";
        throw cet::exception("UnresolvedTuneName")
          << "can't resolve TuneName: " << fhicl_tune_name;
      }
    }

    // If the XSecSplineList returns a non-empty string as the current tune name,
    // then genie::RunOpt::BuildTune() has already been called.
    std::string current_tune = genie::XSecSplineList::Instance()->CurrentTune();
    if ( current_tune.empty() ) {
      // We need to build the GENIE tune config
      mf::LogInfo("EventWeight") << "Configuring GENIE tune \""
        << fhicl_tune_name << '\"';

      // Constructor automatically calls grunopt->Init();
      genie::RunOpt* grunopt = genie::RunOpt::Instance();
      grunopt->SetTuneName( fhicl_tune_name );
      grunopt->BuildTune();
    }
    else {
      // It has already been built, so just check consistency
      if ( fhicl_tune_name != current_tune) {
        throw cet::exception("TuneNameMismatch") << "Requested GENIE tune \""
          << fhicl_tune_name << "\" does not match previously built tune \""
          << current_tune << '\"';
      }
    }

#endif
  }

} // namespace

DEFINE_ART_MODULE(evwgh::EventWeight)
